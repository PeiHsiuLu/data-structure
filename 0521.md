# 第二道題目

## 34. Find First and Last Position of Element in Sorted Array

### 思路

1. 這題型是二分搜尋法基礎再延伸，條件判斷幾乎都是利用相同的思路即可。但是在連續重複數值的尋找必須加倍用心。
2. 使用兩個函式破題，先找左邊最初始的位置，再找最右邊，並且把搜尋左右的函式放在另外一個函式裡面。
3. 用一個主函式來運行，主函式主要是條件判斷。

### 程式碼

```python
class Solution(object):
    def searchRange(self, nums, target): #主函式負責調用副函式
        left = self.binsearch(nums, target, True)  # 先找最左邊的數值
        right = self.binsearch(nums, target, False)  # 再找最右邊的數值
        return [left, right]
    
    def binsearch(self, nums, target, leftBias):
        l = 0  # 設左腳位在最初始位置
        r = len(nums) - 1  # 設右腳位在最末端
        i = -1  # 設初始為-1，因為可能會有搜尋不到的情形
        
        while l <= r:
            mid = (l + r) // 2
            if target < nums[mid]:
                r = mid - 1
            elif target > nums[mid]:
                l = mid + 1
            else:
                i = mid
                # 這樣就不可能出現一邊是-1另一邊是索引的狀況了，
                # 因為如果只有單一數值，則會是[mid, mid]
                if leftBias:
                    r = mid - 1
                else:
                    l = mid + 1
        return i  # 返還數值
```
### 卡關的地方
一開始很天真的使用多個if函式來解只有單個數值的情況，或是長度過短的情況。結果卻造成偵錯時的runtime error

# 第三道題目

## 74. Search a 2D Matrix

### 思路

1. 這題型是二分搜尋法基礎的變形題，但只要找到陣列中的規律，一切都很容易
2. 從母陣列中運用子陣列做二分搜尋法

### 程式碼

```python
class Solution(object):
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        value=False #先設定value為False
        for i in range(len(matrix)):
            r=len(matrix[i])-1 #設定初始右腳位為matrix陣列中第i個子陣列，並尋找長度
            l=0 #設定初始左腳位為0
            while l<=r: #接著就是最尋常的二分搜尋法了
                mid=(r+l)//2
                if matrix[i][mid]==target:
                    value=True
                    return value
                elif matrix[i][mid]>target:
                    r=mid-1
                else:
                    l=mid+1

        return value
        
```
### 卡關的地方
這次重新複習，發現我有時候會有粗心的毛病，可能在條件判斷時，必須先思考一下再下筆。

# 第四道題目

## 81. Search in Rotated Sorted Array II

### 思路

1. 和33題一樣的題型，但是多了重複的數值，必須小心
2. 重複數值必須在條件中用額外的條件處理 (中、左、右三個腳位相同時該如何執行程式？)

### 程式碼

```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: bool
        """
        l=0
        r=len(nums)-1
        while l<=r:
            mid=(r+l)//2
            #當達到target時，直接返回數值
            if nums[mid]==target:
                return True
            
            #當左中右三個數值皆相同時
            if nums[l]==nums[mid]==nums[r]: 
                r-=1
                l+=1
            #尋找左半部分
            #必須先設定一個if假設左半部份是由小到大依序排列
            elif nums[l]<=nums[mid]:
                if nums[l]<=target<nums[mid]:
                    r=mid-1
                else:
                    l=mid+1
            #尋找右半部分        
            else:
                if nums[mid]<target<=nums[r]:
                    l=mid+1
                else:
                    r=mid-1
                
        return False
        
```
### 卡關的地方
重複數值的處哩，一開始天真的認為和33題是一樣的題型，但是跟我想像的還是有落差，因為我沒有處理到重複數值。
33題和81題最不同的地方在於：33題可以按照順序來作為條件判斷，但81題不能夠用重複數值來做處理，因為可能會有l==r==mid的問題

# 第五道題目

## 153. Find Minimum in Rotated Sorted Array

### 思路

1. 一開始原本想直接使用min函式，但我覺得為了以後刷題更輕鬆，我必須練習二分搜尋法的解法
2. middle是關鍵，因為沒有重複數值，而且排得具有順序性，可利用middle與r的大小關係來尋找最小值。

### 程式碼

```python
class Solution(object):
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        l=0
        r=len(nums)-1
        while l<r:
            mid=(l+r)//2
            if nums[mid]>nums[r]:
                l=mid+1
            else:
                r=mid
        return nums[l]
        
```
### 卡關的地方
試圖利用最有效率的方式處理，但還是超時。


