# 第十一道題目
## 378. Kth Smallest Element in a Sorted Matrix

### 思路

1. 利用最小值+最大值除以2，尋找中間值以下(含)的所有值。
2. 基本上是用目前所抓取長度總和來解題，因為長度總和==k，一定是答案

### 程式碼

```python
class Solution(object):
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        """
        n = len(matrix) #因為矩陣都是n*n的二維陣列
        l, h = matrix[0][0], matrix[-1][-1] #最尾端一定是最大值 #最開頭的值一定是最小值

        while l < h:
            m = (l + h) // 2 #找中間的值
            count = 0 #從0開始計算起
            for i in range(n):
                j = 0 #從子陣列的索引0開始遍歷
                while j < n and matrix[i][j] <= m:
                    j += 1
                count += j #每次子陣列遍歷完，就結算一次總合
            
            if count < k:
                l = m + 1 #當count值小於k時，代表還不夠大，將l值設為m+1
            else:
                h = m #當count值大於等於k時，代表>k，或是=k。可能是太大或是剛剛好，不能設為m-1是因為可能包含m值

        return l #此時l==h，所以要回傳l值。
```
### 卡關的地方
以下是我最原始的解法，結果遇上matrix =[[1,2],[1,3]]
就超時了。
```python
class Solution(object):
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        """
        l=matrix[0][0]
        h=matrix[-1][-1]
        count=0
        pre_num=0
        while l<=h:
            m=(l+h)//2
            for i in range(len(matrix)):
                for j in range(len(matrix[i])):
                    if matrix[i][j]<=m:
                        count+=1
                        pre_num=matrix[i][j]
                        
                    else:
                        break
            if count==k:
                return m

            if count>k:
                h=m-1
            elif count<k:
                l=m+1
            count=0
```

# 第十二道題目
## 786. K-th Smallest Prime Fraction

### 思路

1.  建立初始堆 (h)： 首先，透過列表推導式建立了一個包含元組的列表 h，其中每個元組的第一個元素是 1 除以 arr 中每個數的結果，這是為了得到該數的倒數。然後使用 enumerate(arr[1:]) 遍歷 arr 中除了第一個元素外的所有元素，獲取其索引 j 和數值 y，並將其轉換為 (1 / y, 0, j + 1) 的形式。這樣就建立了初始的最小堆。

2.  堆化 (heapify)： 使用 heapify 函數將 h 轉換為最小堆。這一步確保了堆的性質，即堆頂元素是最小的。

3.  迭代計算： 進入迴圈，迭代 k - 1 次。每次迭代都執行以下操作：

4.  從堆 h 中彈出堆頂元素，得到一個分數以及其對應的分子索引 i 和分母索引 j。
檢查如果分子索引加 1 小於分母索引 j，表示還有下一個分數需要計算，則計算下一個分數並將其加入堆中。計算的方式是取 arr 中第 i + 1 個數除以第 j 個數，並將結果和對應的索引 (arr[i + 1] / arr[j], i + 1, j) 加入堆中。
返回結果： 迴圈結束後，堆頂元素即為所求的第 k 小的質數分數。因此，從原始數組 arr 中提取堆頂元素的分子和分母對應的數字，並將其作為結果返回。

### 程式碼

```python
class Solution:
    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
        h = [(1 / y, 0, j + 1) for j, y in enumerate(arr[1:])]
        heapify(h)
        for _ in range(k - 1):
            _, i, j = heappop(h)
            if i + 1 < j:
                heappush(h, (arr[i + 1] / arr[j], i + 1, j))
        return [arr[h[0][1]], arr[h[0][2]]]
```
### 卡關的地方
以下是我最原始的解法，結果一樣超時了。(不夠有效率，通過了一半的測試，但還是一樣在第44/59的測試中，超時了)
```python
class Solution(object):
    def kthSmallestPrimeFraction(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: List[int]
        """
        this_dic={}
        multiply=1
        for x in arr:
            multiply*=x

        for i in range(len(arr)-1):
            for j in range(i+1,len(arr)):
                this_dic[multiply/arr[j]*arr[i]]=[arr[i],arr[j]]
                
        keys_view = this_dic.keys()
        keys_list = list(keys_view)

        n=len(keys_list)
        l=min(keys_list)
        h=max(keys_list)
        

        while l<h:
            m = (l + h) // 2 #找中間的值
            count=0
            for y in range(n):
                if keys_list[y]<=m:
                    count+=1
            if count < k:
                l = m + 1 #當count值小於k時，代表還不夠大，將l值設為m+1
            else:
                h = m #當count值大於等於k時，代表>k，或是=k。可能是太大或是剛剛好，不能設為m-1是因為可能包含m值

        return this_dic[l]
```
原先的思路：利用最小公倍數與字典的鍵來破題